// Code generated by avo.go. DO NOT EDIT.

//go:build amd64 && !purego

package vectorcmp

func VectorEquals8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2() && len(rows) >= 64 {
		asmAVX2Equals8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		asmAVXEquals8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorGreaterThan8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2() && len(rows) >= 64 {
		asmAVX2GreaterThan8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		asmAVXGreaterThan8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorLessThan8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2() && len(rows) >= 64 {
		asmAVX2LessThan8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		asmAVXLessThan8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorGreaterEquals8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2() && len(rows) >= 64 {
		asmAVX2GreaterEquals8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		asmAVXGreaterEquals8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorLesserEquals8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2() && len(rows) >= 64 {
		asmAVX2LesserEquals8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		asmAVXLesserEquals8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorEquals16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2() && len(rows) >= 32 {
		asmAVX2Equals16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		asmAVXEquals16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorGreaterThan16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2() && len(rows) >= 32 {
		asmAVX2GreaterThan16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		asmAVXGreaterThan16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorLessThan16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2() && len(rows) >= 32 {
		asmAVX2LessThan16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		asmAVXLessThan16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorGreaterEquals16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2() && len(rows) >= 32 {
		asmAVX2GreaterEquals16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		asmAVXGreaterEquals16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorLesserEquals16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2() && len(rows) >= 32 {
		asmAVX2LesserEquals16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		asmAVXLesserEquals16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorEquals32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2() && len(rows) >= 16 {
		asmAVX2Equals32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		asmAVXEquals32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorGreaterThan32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2() && len(rows) >= 16 {
		asmAVX2GreaterThan32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		asmAVXGreaterThan32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorLessThan32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2() && len(rows) >= 16 {
		asmAVX2LessThan32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		asmAVXLessThan32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorGreaterEquals32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2() && len(rows) >= 16 {
		asmAVX2GreaterEquals32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		asmAVXGreaterEquals32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorLesserEquals32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2() && len(rows) >= 16 {
		asmAVX2LesserEquals32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		asmAVXLesserEquals32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorEquals64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2() && len(rows) >= 8 {
		asmAVX2Equals64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorGreaterThan64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2() && len(rows) >= 8 {
		asmAVX2GreaterThan64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorLessThan64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2() && len(rows) >= 8 {
		asmAVX2LessThan64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorGreaterEquals64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2() && len(rows) >= 8 {
		asmAVX2GreaterEquals64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorLesserEquals64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2() && len(rows) >= 8 {
		asmAVX2LesserEquals64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
